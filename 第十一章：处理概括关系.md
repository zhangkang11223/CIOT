##  摘要：本章讲述在对象的设计过程中，用一种专门的手法处理类的继承关系
### 1 上移
#### 1.1 Pull Up Field（字段上移）
 * 现象：两个子类拥有相同的字段
 * 动机：去除重复声明；去除重复行为
 * 做法：将该字段移至超类
 * 例子：把2个子类的相同的字段price上移父类Book
```
    //抽象类Book
    public abstract class Book{}

    //实现类漫画
    public class Comic extends Book{
        private Double price = 30.0;
    }

    //实现类小说
    public class Fiction xtends Book{
        private Double price = 50.0;
    }

    /************字段上移到基类****************/

    public abstract class Book{
        protected Double price;  //思考：这里为什么要用protected
    }

    public class Comic extends Book{}

    public class Fiction extends Book{}
 ```
#### 1.2 Pull Up Method（函数上移）
 * 现象：有些函数，在各个子类中产生完全相同的结果
 * 动机：去除重复行为
 * 做法：将该函数移至超类
 * 例子：把2个子类的相同的方法createBill()上移到父类Customer
  ```
    //抽象类顾客
    public abstract class Customer{}
    
    //普通顾客
    public class CheckingAccount extends Customer{
        
        void createBill (date Date) {

           double chargeAmount = chargeFor(lastBillDate, date);

           addBill (date, charge);

        }
    }
    
    //贵宾
    public class  PreferredCustomer extends Customer{
    
         void createBill (date Date) {

           double chargeAmount = chargeFor(lastBillDate, date);

           addBill (date, charge);

        }
    }
    
    
    /******把createBill()方法上移到父类******/
    public abstract class Customer{
        
        void createBill (date Date) {

           double chargeAmount = chargeFor(lastBillDate, date);

           addBill (date, charge);

        }
        
        abstract double chargeFor(date start, date end);
        abstract double addBill(date date, double charge);
        
    }
    
    
  ```
#### 1.3 Pull Up Constructor Body（构造函数本体上移）
 * 现象：各个子类中拥有一些构造函数，它们的本体几乎完全一致
 * 动机：去除重复行为
 * 做法：在超类中新建一个构造函数，并在子类构造函数中调用它
 * 例子: 在Employee类中创建构造函数，在Manager类中调用超类（Employee）的构造函数
 ```
 class Manager extends Employee{
   ...
   public Manager (String name, String id, int grade) {
       _name = name;
       _id = id;
       _grade = grade;

   }
 }
 
 /***************构造函数上移***************/
 
 class Employee{
     ...
     Employee(String name, String id){
          _name = name;

           _id = id;
     }
 }
 
 class Manager extends Employee{
     ...
     public Manager (String name, String id, int grade) {
           super (name, id);
           _grade = grade;

     }
 }
 ```
### 2 下移
#### 2.1 Push Down Field（字段下移）
 * 现象：超类中的某个字段只被部分（而非全部）子类用到
 * 动机：明确职责
 * 做法：将这个字段移到需要它的子类中
 * 例子:
 ```
 class Employee {
    protected Double quota;//指定额度，限额  
 }
 
 class Salesman extends Employee {}
 
 class Engineer extends Employee {}
 
 /**************字段下移***************/
 
 class Employee {}
 
 class Salesman extends Employee {
     protected Double quota;//指定额度，限额  
 }

class Engineer extends Employee {}
 ```
 
#### 2.2 Push Down Method（函数下移）
 * 现象：超类中的某个函数只与部分（而非全部）子类有关
 * 动机：职责划分需要清晰，下移能明确表示某些子类不背负这些函数的任务
 * 做法：将这个函数移到相关的子类中
 * 例子:
 ```
 class Employee {
    ...
    public double getQuota(){
        return this.quota;
    }
 }
 
 class Salesman extends Employee {}
 
 class Engineer extends Employee {}
 
 /**************函数下移***************/
 
 class Employee {}
 
 class Salesman extends Employee {
    ...
    public double getQuota(){
        return this.quota;
    }
 }

class Engineer extends Employee {}
```
 
 
 

#### 2.3 Extract Subclass（提炼子类）
 * 现象：类中的某些特性只被某些（而非全部）实例用到
 * 动机：明确职责
 * 做法：新建一个子类，将这些特性移到子类中
 ```
class JobItem {

   private int _unitPrice;
   private int _quantity;
   private Employee _employee;
   private boolean _isLabor;        
   
   public JobItem (int unitPrice, int quantity, boolean isLabor, Employee employee) {
       _unitPrice = unitPrice;
       _quantity = quantity;
       _isLabor = isLabor;
       _employee = employee;

   }

   public int getTotalPrice() {
       return getUnitPrice() * _quantity;
   }

   public int getUnitPrice(){
       return (_isLabor) ? _employee.getRate() : _unitPrice;
   }
   
   public int getQuantity(){ return _quantity; }
   public Employee getEmployee() { return _employee; }

}

class Employee {
   public Employee (int rate) { _rate = rate; }
   public int getRate() { return _rate; }
   private int _rate;
}


/*****************提炼子类LaborItem ****************/

 public LaborItem (int unitPrice, int quantity, boolean isLabor, Employee employee) {
       super (unitPrice, quantity, isLabor, employee);
 }





```
### 3 提炼
#### 2.1 Extract SuperClass（提炼超类）
 * 现象：两个类有相似特性
 * 动机：去除重复代码
 * 做法：为这两个类建立一个超类，将相同特性移至超类
#### 2.2 Extract Interface（提炼接口）
 * 现象：多个客户端使用类接口中的同一子集，或者两个类的接口有部分相同
 * 动机：接口职责更清晰
 * 做法：将相同的子集提炼到一个独立的接口
#### 2.3 Collapse Hierarchy（折叠继承体系）
 * 现象：超类和子类之间无太大区别
 * 动机：继承体系需要简洁清晰
 * 做法：把超类和子类合在一起
### 4 继承与委托
#### 4.1 Replace Inheritance with Delegation（以委托取代继承）
 * 现象：某个子类只使用超类接口的一部分，或者根本不需要继承来的数据
 * 动机：委托比继承更安全且灵活
 * 做法：在子类中新建一个字段来保存超类；调整子类函数，令它委托超类；去掉两者之间的继承关系
#### 4.2 Replace Delegation with Inheritance（以继承取代委托）
 * 现象：两个类之间使用委托关系，但是接口中出现大量的简单的委托函数
 * 动机：使用继承可以一下子干掉无聊繁杂的委托函数
 * 做法：让委托类继承受托类
### 5 模板
#### 5.1 Form Template Method（塑造模板函数）
 * 现象：一些子类的某些相应函数执行顺序相似，但是操作细节各不相同
 * 动机：降低子类复杂度
 * 做法：使用模板方法
